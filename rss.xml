<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="assets/xml/rss.xsl" media="all"?><rss version="2.0" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Laptop Biology</title><link>https://laptopbiologist.github.io/</link><description>Genomics, Pythonics, Philosoophics, I am restricting myself to things ending in -ic</description><atom:link href="https://laptopbiologist.github.io/rss.xml" rel="self" type="application/rss+xml"></atom:link><language>en</language><copyright>Contents © 2018 &lt;a href="mailto:mpm289@cornell.edu"&gt;Michael McGurk&lt;/a&gt; </copyright><lastBuildDate>Sun, 11 Nov 2018 19:33:28 GMT</lastBuildDate><generator>Nikola (getnikola.com)</generator><docs>http://blogs.law.harvard.edu/tech/rss</docs><item><title>Maybe now I can actually learn C++ - Interactive C++ in Jupyter Notebooks</title><link>https://laptopbiologist.github.io/posts/using-c%2B%2B-in-Jupyter/</link><dc:creator>Michael McGurk</dc:creator><description>&lt;div tabindex="-1" id="notebook" class="border-box-sizing"&gt;
    &lt;div class="container" id="notebook-container"&gt;

&lt;div class="cell border-box-sizing text_cell rendered"&gt;&lt;div class="prompt input_prompt"&gt;
&lt;/div&gt;
&lt;div class="inner_cell"&gt;
&lt;div class="text_cell_render border-box-sizing rendered_html"&gt;
&lt;p&gt;Okay. This was a pain in the butt. But it was worth it.&lt;/p&gt;
&lt;p&gt;The reason I'm so comfortable with Python is that you don't have to explicitly compile it to understand how code behaves. You can write functions and immediately play around with them to understand how they behave. It makes developing and learning iterative procedures of trial and error, and it makes the language very approachable.&lt;/p&gt;
&lt;p&gt;I've never been able to do this with C++ before, and consequently I'm far less comfortable with C++. C++ is a compiled language, so you have to write the entire program, compile it, and then run it as an executable to see what it does. It adds time and effort and possible errors/frustration between writing the code and understanding how it behaves. But C++ has some very nice libraries for a variety of tasks and it's often much faster than Python. More importantly, it's possible to extend Python functions with C++ functions, so facility with C++ can supplement the life mostly Pythonic. Now, for many tasks you can bring Python very close to C-like speed with the clever use of Numpy, but this can be challenging and sometimes just not possible. Fortunately, the physicists at CERN didn't just give us the World Wide Web, they more recently developed an interpreted C++, Cling. And it's available in Jupyter as the &lt;a href="https://blog.jupyter.org/interactive-workflows-for-c-with-jupyter-fe9b54227d92"&gt;Xeus-Cling kernel&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;I tried the Windows installer, but Xeus-cling doesn't actually support Windows yet. It half-worked, but it didn't handle output properly. Because I have Windows 10, what I ended up doing is installing it on my &lt;a href="https://docs.microsoft.com/en-us/windows/wsl/install-win10"&gt;Windows Subsystem for Linux&lt;/a&gt;. In principle, that should've been super easy, but Conda kept hanging when it tried to download the larger dependencies.&lt;/p&gt;
&lt;p&gt;In my WSL terminal:&lt;/p&gt;
&lt;p&gt;&lt;code&gt;conda create -n cling&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;source activate cling&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;conda install xeus-cling notebook jupyterlab -c QuantStack -c conda-forge&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;The last command I had to run many many times, due to the aforementioned hanging. Finally, disproving Einstein's supposed definition of insanity--"doing the same thing over and over again and expecting a different result"--in the common case that there's some unobserved variable determining success versus failure, it installed. After exiting and restarting the terminal, I can do this:&lt;/p&gt;

&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="cell border-box-sizing code_cell rendered"&gt;
&lt;div class="input"&gt;
&lt;div class="prompt input_prompt"&gt;In [2]:&lt;/div&gt;
&lt;div class="inner_cell"&gt;
    &lt;div class="input_area"&gt;
&lt;div class=" highlight hl-c++"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="cp"&gt;#include&lt;/span&gt; &lt;span class="cpf"&gt;&amp;lt;iostream&amp;gt;&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;
&lt;span class="k"&gt;using&lt;/span&gt; &lt;span class="k"&gt;namespace&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div class="output_wrapper"&gt;
&lt;div class="output"&gt;


&lt;div class="output_area"&gt;

&lt;div class="prompt"&gt;&lt;/div&gt;


&lt;div class="output_subarea output_stream output_stderr output_text"&gt;
&lt;pre&gt;&lt;span class="ansi-bold"&gt;input_line_10:1:20: &lt;/span&gt;&lt;span class="ansi-red-intense-fg ansi-bold"&gt;error: &lt;/span&gt;&lt;span class="ansi-bold"&gt;expected ';' after namespace name&lt;/span&gt;
using namespace std
&lt;span class="ansi-green-intense-fg ansi-bold"&gt;                   ^
&lt;/span&gt;&lt;span class="ansi-green-fg"&gt;                   ;
&lt;/span&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div class="output_area"&gt;

&lt;div class="prompt"&gt;&lt;/div&gt;


&lt;div class="output_subarea output_text output_error"&gt;
&lt;pre&gt;
Interpreter Error: &lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;/div&gt;
&lt;/div&gt;

&lt;/div&gt;
&lt;div class="cell border-box-sizing text_cell rendered"&gt;&lt;div class="prompt input_prompt"&gt;
&lt;/div&gt;
&lt;div class="inner_cell"&gt;
&lt;div class="text_cell_render border-box-sizing rendered_html"&gt;
&lt;p&gt;&lt;br&gt;
Look! I did something wrong and found out immediately. &lt;strong&gt;Bully for interpreters!&lt;/strong&gt;&lt;/p&gt;

&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="cell border-box-sizing code_cell rendered"&gt;
&lt;div class="input"&gt;
&lt;div class="prompt input_prompt"&gt;In [3]:&lt;/div&gt;
&lt;div class="inner_cell"&gt;
    &lt;div class="input_area"&gt;
&lt;div class=" highlight hl-c++"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="cp"&gt;#include&lt;/span&gt; &lt;span class="cpf"&gt;&amp;lt;iostream&amp;gt;&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;
&lt;span class="k"&gt;using&lt;/span&gt; &lt;span class="k"&gt;namespace&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;/div&gt;
&lt;div class="cell border-box-sizing text_cell rendered"&gt;&lt;div class="prompt input_prompt"&gt;
&lt;/div&gt;
&lt;div class="inner_cell"&gt;
&lt;div class="text_cell_render border-box-sizing rendered_html"&gt;
&lt;p&gt;&lt;br&gt;
Let's be traditional:&lt;/p&gt;

&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="cell border-box-sizing code_cell rendered"&gt;
&lt;div class="input"&gt;
&lt;div class="prompt input_prompt"&gt;In [4]:&lt;/div&gt;
&lt;div class="inner_cell"&gt;
    &lt;div class="input_area"&gt;
&lt;div class=" highlight hl-c++"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;cout&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class="s"&gt;"Hello world"&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div class="output_wrapper"&gt;
&lt;div class="output"&gt;


&lt;div class="output_area"&gt;

&lt;div class="prompt"&gt;&lt;/div&gt;


&lt;div class="output_subarea output_stream output_stdout output_text"&gt;
&lt;pre&gt;Hello world&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;/div&gt;
&lt;/div&gt;

&lt;/div&gt;
&lt;div class="cell border-box-sizing code_cell rendered"&gt;
&lt;div class="input"&gt;
&lt;div class="prompt input_prompt"&gt;In [5]:&lt;/div&gt;
&lt;div class="inner_cell"&gt;
    &lt;div class="input_area"&gt;
&lt;div class=" highlight hl-c++"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="n"&gt;cout&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div class="output_wrapper"&gt;
&lt;div class="output"&gt;


&lt;div class="output_area"&gt;

&lt;div class="prompt"&gt;&lt;/div&gt;


&lt;div class="output_subarea output_stream output_stdout output_text"&gt;
&lt;pre&gt;3&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;/div&gt;
&lt;/div&gt;

&lt;/div&gt;
&lt;div class="cell border-box-sizing text_cell rendered"&gt;&lt;div class="prompt input_prompt"&gt;
&lt;/div&gt;
&lt;div class="inner_cell"&gt;
&lt;div class="text_cell_render border-box-sizing rendered_html"&gt;
&lt;p&gt;&lt;br&gt;
Just some notes on running this on the WSL. The WSL is not designed to run GUIs (Graphical User Interfaces) but Jupyter Lab is run in a web browser. One option is to follow this &lt;a href="https://virtualizationreview.com/articles/2017/02/08/graphical-programs-on-windows-subsystem-on-linux.aspx"&gt;guide&lt;/a&gt; and run Firefox/Chrome in the WSL with an X-server. This is far less complicated than it sounds. First, you add a line at the end of the .bashrc file, to set it up processing graphics. Then you turn on the X-server--I opened up MobaxTerm and just clicked the "Start X-server" function. Restart the terminal, install a browser, and run Jupyter Lab. &lt;br&gt;&lt;/p&gt;
&lt;p&gt;The problem with this is that WSL is still not designed for GUIs. So while it will run, it ends up looking like you're running it on your grandfather's Windows 3.1 machine back in the early 1990s. And this is pretty distracting. And  it gives me flashbacks of 8-year-old-Me's early attempts to write computer games on my grandfather's PC by creating new files, naming them evocatively, and then wondering why nothing happened when I opened them.
&lt;br&gt;&lt;/p&gt;
&lt;p&gt;My work-around is to simply copy the link Jupyter Lab provides when it starts, into my normal browser running on Windows. So Jupyter Lab runs on the Linux Subsystem but I use Firefox running on Windows as my interface.&lt;br&gt;&lt;/p&gt;
&lt;p&gt;As I mentioned, I've never been able to do this with C++ before. But now I can and it feels the opening of doors.&lt;/p&gt;

&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
    &lt;/div&gt;
  &lt;/div&gt;
</description><category>C++</category><category>Jupyter</category><category>programming</category><guid>https://laptopbiologist.github.io/posts/using-c%2B%2B-in-Jupyter/</guid><pubDate>Sun, 11 Nov 2018 09:29:00 GMT</pubDate></item><item><title>Setting up this site - Part 1</title><link>https://laptopbiologist.github.io/posts/setting-up-this-site-part-1/</link><dc:creator>Michael McGurk</dc:creator><description>&lt;div&gt;&lt;p&gt;I've wanted to set up a research blog for a while now. Over the course of any project you stumble across tricks and tools that you can't really emphasize in publications (due to space or focus considerations), but which would be probably helpful to other researchers. Sure, they end up in the (supplemental) methods, but no one is going to find them. And frankly, the solutions to many of the stumbling blocks I've stumbled upon or the "_Eureka!_"-shouting resolution to tricky concepts are found, not in publications, but in the helpful blog posts other researchers took the time to write and publish. Thanks to the internet, the way we disseminate information as researchers has moved beyond conferences and publications (certainly not an original conclusion), and I want to make an active effort to pay forward some of those private _eurekas_.&lt;/p&gt;
&lt;p&gt;But I'm a biologist not a computer scientist by training. I think the last time I tried setting anything up resembling a blog was when I made a MySpace page for my cat back in high school (draw for yourself whatever conclusions arise naturally from that admission). So creating a science blog required a bit of planning and consideration. There were several things I knew I wanted. First, I didn't want to pay for anything. Second, however I set up this blog, I wanted the option of directly generating it from my research notes. The reason is I want to lower the activation energy necessary to communicate an idea (I believe accounting for future laziness is key to productivity). These days, my notes are almost exclusively found in Jupyter notebooks, and I've increasingly relied on [Colaboratory](&lt;a class="reference external" href="https://colab.research.google.com/"&gt;https://colab.research.google.com/&lt;/a&gt;) (which is basically Google Docs, but for Jupyter notebooks). So a format that can be painlessly generated from Jupyter notebooks was a must. Another consideration is where should I host this blog.&lt;/p&gt;
&lt;p&gt;Googling around for options answered two questions at once "How do I do this?" and "Where do I host the blog?" with  _[Github Pages](with: &lt;a class="reference external" href="https://pages.github.com/)_"&gt;https://pages.github.com/)_&lt;/a&gt;. As it turns out, GitHub--where I store and version control most of my code--allows users to host (for free) static web pages in a repository titled username.github.io. The restriction that they be static meant that the "How?" probably ought to be something that can generate static web pages. It looked like there were several appealling options, with Jekyll and Pelican being the most commonly recommended. I played with Jekyll and bit a really liked (for great ), but all of the guides for converting Jupyter notebooks to web pages seemed like the process was clunky. So I went with Pelican (which is apparently an anagram of the French for 'notebook': calepin)&lt;/p&gt;&lt;/div&gt;</description><guid>https://laptopbiologist.github.io/posts/setting-up-this-site-part-1/</guid><pubDate>Tue, 16 Oct 2018 02:03:03 GMT</pubDate></item></channel></rss>